package oatool

/*
 Base package for tools used to manipulate data in different format : json, yaml, binary (from protobuf def)
*/
import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"reflect"
	"strings"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"gopkg.in/yaml.v3"
)

//YAML to JSON Converter

// y2jConvert : used by yaml2Json
func y2jConvert(i interface{}) interface{} {
	switch x := i.(type) {
	case map[interface{}]interface{}:
		m2 := map[string]interface{}{}
		for k, v := range x {
			m2[k.(string)] = y2jConvert(v)
		}
		return m2
	case []interface{}:
		for i, v := range x {
			x[i] = y2jConvert(v)
		}
	}
	return i
}

// yaml2Json : credits : stackoverflow ;)
func yaml2Json(buf []byte) ([]byte, error) {
	var body interface{}
	if err := yaml.Unmarshal(buf, &body); err != nil {
		return nil, err
	}

	body = y2jConvert(body)

	b, err := json.Marshal(body)

	return b, err
}

//JSON to YAML Converter

//j2yConvert : used by json2Yaml
func j2yConvert(i interface{}) interface{} {
	switch x := i.(type) {
	case map[string]interface{}:
		m2 := map[interface{}]interface{}{}
		for k, v := range x {
			m2[j2yConvert(k)] = j2yConvert(v)
		}
		return m2
	case []interface{}:
		for i, v := range x {
			x[i] = j2yConvert(v)
		}
		return x
	case string:
		return i
	case bool:
		return i
	case float64:
		return i
	default:
		fmt.Fprintf(os.Stderr, "j2yConvert : Unmatched type %v\n", reflect.TypeOf(i))
		return i
	}
}

// Json2Yaml Convert any JSON formatted data-block to YAML data-block
func json2Yaml(buf []byte) ([]byte, error) {
	var body interface{}
	if err := json.Unmarshal(buf, &body); err != nil {
		return nil, err
	}

	body = j2yConvert(body)

	b, err := yaml.Marshal(body)
	return b, err

}

//data2Object Convert object which has proto, json, yaml interface to data
func data2Object(obj proto.Message, data []byte, intype string) error {
	var err error
	switch intype {
	case "json":
		err = protojson.Unmarshal(data, obj)
	case "yaml":
		var jsonFile []byte
		jsonFile, err = yaml2Json(data)
		if err != nil {
			return err
		}
		err = protojson.Unmarshal(jsonFile, obj)
	case "bin":
		err = proto.Unmarshal(data, obj)
	default:
		err = fmt.Errorf("data2Object: Unknown source type %s", intype)
	}
	return err
}

// objet2Data
func objet2Data(obj proto.Message, outtype string) ([]byte, error) {
	var out []byte
	var err error
	switch outtype {
	case "json":
		out, err = protojson.Marshal(obj)
	case "yaml":
		data, err := protojson.Marshal(obj)
		if err != nil {
			return nil, err
		}
		out, err = json2Yaml(data)
	case "bin":
		out, err = proto.Marshal(obj)
	default:
		err = fmt.Errorf("objet2Data: Unknown destination type %s", outtype)
	}
	return out, err
}

// Load : this function load a file and unmarshall file into obj. File can have different formats depending on its extension
// .json -> json file 
// .yaml -> yaml file
// any -> binary protobuf encoded
func Load(file string, obj proto.Message) error {
	var data []byte
	var err error

	sl := strings.Split(file, ".")
	intype := sl[len(sl)-1]

	data, err = ioutil.ReadFile(file)
	if err != nil {
		return err
	}
	if intype != "json" && intype != "yaml" {
		intype = "bin"
	}
	err = data2Object(obj, data, intype)
	if err != nil {
		return err
	}
	return nil
}

// MainObjTool generic main function for tool generated by oatoolgen
func MainObjTool(obj proto.Message) {
	var input = flag.String("if", "", "input file .json/.yaml/.bin")
	var output = flag.String("of", "", "<file>.json|yaml|bin")
	var toformat = flag.String("tofmt", "", "json|yaml|bin force output format")
	
	var out []byte
	var format string
	var outfile *os.File
	// CommandLine parsing
	flag.Parse()

	err := Load(*input, obj)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error Loading file: %v\n", err)
		os.Exit(1)
	}

	format = *toformat
	// output format depend on extension
	if *output == "" {
		// output to stdout
		outfile = os.Stdout
	} else {
		// if no format choosen => try to choose one regarding output extension
		if format == "" {
			sl := strings.Split(*output, ".")
			format = sl[len(sl)-1]
		}
		// Open file
		var err error
		outfile, err = os.Create(*output)
		if err != nil {
			fmt.Fprintf(os.Stderr, "error %v\n", err)
		}
		defer outfile.Close()
	}

	// in cas of bad format force to binary
	if format != "json" && format != "yaml" && format != "bin" {
		fmt.Println("unknown output format choosing binary")
		format = "bin"
	}

	// convert object to output format
	out, err = objet2Data(obj, format)

	if err != nil {
		fmt.Fprintf(os.Stderr, "error Marshalling: %v\n", err)
		os.Exit(1)
	}

	outfile.Write(out)
}

// MainOAFileTool generic main function for tool generated by oatoolgen - DEpreacated
func MainOAFileTool(getObj func(string) proto.Message) {
	var file = flag.String("f", "", "input file .json/.yaml/.bin")
	var format = flag.String("o", "bin", "json|yaml|bin")
	var root = flag.String("r", "", "")
	var generate = flag.Bool("g", false, "generate empty file")
	var out []byte
	var err error

	// CommandLine parsing
	flag.Parse()

	// Create Object by using passed callback
	obj := getObj(*root)
	if obj == nil {
		fmt.Fprintf(os.Stderr, "error unknown component object : %s\n", *root)
		os.Exit(1)
	}

	// -g case, generate empty file (experimental)
	// if not => load file, then detect input format (based on file extension), then create obj from file content
	if !*generate {
		var data []byte
		sl := strings.Split(*file, ".")
		intype := sl[len(sl)-1]

		data, err = ioutil.ReadFile(*file)
		if err != nil {
			fmt.Fprintf(os.Stderr, "error opening %s  #%v \n", *file, err)
			os.Exit(1)
		}

		err = data2Object(obj, data, intype)
		if err != nil {
			fmt.Fprintf(os.Stderr, "error Unmarshalling data %s  #%v \n", *file, err)
			os.Exit(1)
		}
	}
	// convert object to output format
	out, err = objet2Data(obj, *format)

	if err != nil {
		fmt.Fprintf(os.Stderr, "error Marshalling: %v\n", err)
		os.Exit(1)
	}

	os.Stdout.Write(out)
	ioutil.WriteFile("output."+*format, out, 0666)
}
