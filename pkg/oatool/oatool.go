package oatool

/*
 Base package for tools used to manipulate data in different format : json, yaml, binary (from protobuf def)
*/
import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"reflect"
	"strings"

	"github.com/golang/protobuf/proto"
	"gopkg.in/yaml.v3"
)

//YAML to JSON Converter

// y2jConvert : used by yaml2Json
func y2jConvert(i interface{}) interface{} {
	switch x := i.(type) {
	case map[interface{}]interface{}:
		m2 := map[string]interface{}{}
		for k, v := range x {
			m2[k.(string)] = y2jConvert(v)
		}
		return m2
	case []interface{}:
		for i, v := range x {
			x[i] = y2jConvert(v)
		}
	}
	return i
}

// yaml2Json : credits : stackoverflow ;)
func yaml2Json(buf []byte) ([]byte, error) {
	var body interface{}
	if err := yaml.Unmarshal(buf, &body); err != nil {
		return nil, err
	}

	body = y2jConvert(body)

	b, err := json.Marshal(body)
	return b, err
}

//JSON to YAML Converter

//j2yConvert : used by json2Yaml
func j2yConvert(i interface{}) interface{} {
	switch x := i.(type) {
	case map[string]interface{}:
		m2 := map[interface{}]interface{}{}
		for k, v := range x {
			m2[j2yConvert(k)] = j2yConvert(v)
		}
		return m2
	case []interface{}:
		for i, v := range x {
			x[i] = j2yConvert(v)
		}
		return x
	case string:
		return i
	case bool:
		return i
	case float64:
		return i
	default:
		fmt.Fprintf(os.Stderr, "j2yConvert : Unmatched type %v\n", reflect.TypeOf(i))
		return i
	}
}

// Json2Yaml Convert any JSON formatted data-block to YAML data-block
func json2Yaml(buf []byte) ([]byte, error) {
	var body interface{}
	if err := json.Unmarshal(buf, &body); err != nil {
		return nil, err
	}

	body = j2yConvert(body)

	b, err := yaml.Marshal(body)
	return b, err

}

//data2Object Convert object which has proto, json, yaml interface to data
func data2Object(obj interface{}, data []byte, intype string) error {
	var err error
	switch intype {
	case "json":
		err = json.Unmarshal(data, obj)
	case "yaml":
		var jsonFile []byte
		jsonFile, err = yaml2Json(data)
		if err != nil {
			return err
		}
		err = json.Unmarshal(jsonFile, obj)
	case "bin":
		err = proto.Unmarshal(data, obj.(proto.Message))
	default:
		err = fmt.Errorf("data2Object: Unknown source type %s", intype)
	}
	return err
}

// objet2Data
func objet2Data(obj interface{}, outtype string) ([]byte, error) {
	var out []byte
	var err error
	switch outtype {
	case "json":
		out, err = json.Marshal(obj)
	case "yaml":
		var jbuf []byte
		jbuf, err = json.Marshal(obj)
		if err != nil {
			return nil, err
		}
		out, err = json2Yaml(jbuf)
	case "bin":
		out, err = proto.Marshal(obj.(proto.Message))
	default:
		err = fmt.Errorf("objet2Data: Unknown destination type %s", outtype)
	}
	return out, err
}

// MainOAFileTool generic main function for tool generated by oatoolgen
func MainOAFileTool(getObj func(string) interface{}) {
	var file = flag.String("f", "", "input file .json/.yaml/.bin")
	var format = flag.String("o", "bin", "json|yaml|bin")
	var root = flag.String("r", "", "")
	var generate = flag.Bool("g", false, "generate empty file")
	var out []byte
	var err error

	// CommandLine parsing
	flag.Parse()

	// Create Object by using passed callback
	obj := getObj(*root)
	if obj == nil {
		fmt.Fprintf(os.Stderr, "error unknown component object : %s\n", *root)
		os.Exit(1)
	}

	// -g case, generate empty file (experimental)
	// if not => load file, then detect input format (based on file extension), then create obj from file content
	if !*generate {
		var data []byte
		sl := strings.Split(*file, ".")
		intype := sl[len(sl)-1]

		data, err = ioutil.ReadFile(*file)
		if err != nil {
			fmt.Fprintf(os.Stderr, "error opening %s  #%v \n", *file, err)
			os.Exit(1)
		}

		err = data2Object(obj, data, intype)
		if err != nil {
			fmt.Fprintf(os.Stderr, "error Unmarshalling data %s  #%v \n", *file, err)
			os.Exit(1)
		}
	}
	// convert object to output format
	out, err = objet2Data(obj, *format)

	if err != nil {
		fmt.Fprintf(os.Stderr, "error Marshalling: %v\n", err)
		os.Exit(1)
	}

	os.Stdout.Write(out)
	ioutil.WriteFile("output."+*format, out, 0666)
}
