package main

import (
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/Axili39/encodingtools"
	"google.golang.org/protobuf/proto"
)

// mainObjTool generic main function for tool generated by oatoolgen
func mainObjTool(obj proto.Message) {
	var input = flag.String("if", "", "input file .json/.yaml/.bin")
	var output = flag.String("of", "", "<file>.json|yaml|bin")
	var toformat = flag.String("tofmt", "", "json|yaml|bin force output format")

	var out []byte
	var format string
	var outfile *os.File
	// CommandLine parsing
	flag.Parse()

	// TODO : if no input, just make a minimal data file
	err := encodingtools.Load(*input, obj)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error Loading file: %v\n", err)
		os.Exit(1)
	}

	format = *toformat
	// output format depend on extension
	if *output == "" {
		// output to stdout
		outfile = os.Stdout
	} else {
		// if no format chosen => try to choose one regarding output extension
		if format == "" {
			sl := strings.Split(*output, ".")
			format = sl[len(sl)-1]
		}
		// Open file
		var err error
		outfile, err = os.Create(*output)
		if err != nil {
			fmt.Fprintf(os.Stderr, "error %v\n", err)
		}
		defer outfile.Close()
	}

	// in cas of bad format force to binary
	if format != "json" && format != "yaml" && format != "bin" {
		fmt.Println("unknown output format choosing binary")
		format = "bin"
	}

	// convert object to output format
	out, err = encodingtools.Objet2Bytes(obj, encodingtools.EncodingTypeFromString(format))

	if err != nil {
		fmt.Fprintf(os.Stderr, "error Marshalling: %v\n", err)
		os.Exit(1)
	}

	_, err = outfile.Write(out)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error saving file: %v\n", err)
		os.Exit(1)
	}
}

func main() {
	var obj {{.Component}}
	mainObjTool(&obj)
}